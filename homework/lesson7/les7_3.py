# 3. Реализовать программу работы с органическими клетками. Необходимо создать класс Клетка.
# В его конструкторе инициализировать параметр, соответствующий количеству клеток (целое число).
# В классе должны быть реализованы методы перегрузки арифметических операторов:
#       сложение (__add__()),
#       вычитание (__sub__()),
#       умножение (__mul__()),
#       деление (__truediv__()).
# Данные методы должны применяться только к клеткам и выполнять увеличение, уменьшение, умножение
# и обычное (не целочисленное) деление клеток, соответственно. В методе деления должно осуществляться
# округление значения до целого числа.

# Сложение. Объединение двух клеток. При этом число ячеек общей клетки должно
# равняться сумме ячеек исходных двух клеток.

# Вычитание. Участвуют две клетки. Операцию необходимо выполнять только если разность количества
# ячеек двух клеток больше нуля, иначе выводить соответствующее сообщение.

# Умножение. Создается общая клетка из двух. Число ячеек общей клетки определяется как произведение
# количества ячеек этих двух клеток.

# Деление. Создается общая клетка из двух. Число ячеек общей клетки определяется как целочисленное
# деление количества ячеек этих двух клеток.

# В классе необходимо реализовать метод make_order(), принимающий экземпляр класса и количество
# ячеек в ряду. Данный метод позволяет организовать ячейки по рядам.
# Метод должен возвращать строку вида *****\n*****\n*****..., где количество ячеек между \n
# равно переданному аргументу. Если ячеек на формирование ряда не хватает, то в последний ряд
# записываются все оставшиеся.
# Например, количество ячеек клетки равняется 12, количество ячеек в ряду — 5. Тогда метод make_order()
# вернет строку: *****\n*****\n**.
# Или, количество ячеек клетки равняется 15, количество ячеек в ряду — 5. Тогда метод make_order()
# вернет строку: *****\n*****\n*****.


class Cell:

    def __init__(self, n: int):
        self.__count = n

    def __add__(self, other):
        try:
            if not isinstance(other, Cell):
                raise TypeError()
            return Cell(self.__count + other.__count)
        except TypeError:
            print("Ошибка: операции применимы только для класса Cell")

    def __sub__(self, other):
        try:
            if not isinstance(other, Cell):
                raise TypeError()
            if self.__count - other.__count <= 0:
                raise ValueError()
            return Cell(self.__count - other.__count)
        except TypeError:
            print("Ошибка: операции применимы только для класса Cell")
        except ValueError:
            print("Ошибка: размеры клеток равны или первая клетка меньше")

    def __mul__(self, other):
        try:
            if not isinstance(other, Cell):
                raise TypeError()
            return Cell(self.__count * other.__count)
        except TypeError:
            print("Ошибка: операции применимы только для класса Cell")

    def __truediv__(self, other):
        try:
            if not isinstance(other, Cell):
                raise TypeError()
            return Cell(self.__count // other.__count)
        except TypeError:
            print("Ошибка: операции применимы только для класса Cell")

    def __str__(self):
        return str(f'В клетке находится {self.__count} ячеек')

    def make_order(self, cell_in_row=5):
        count = self.__count
        result = ''
        while count:
            if count >= cell_in_row:
                result += '*'*cell_in_row + '\n'
                count -= cell_in_row
            else:
                result += '*'*count + '\n'
                count = 0
        return result[0: -1: 1]


c1 = Cell(12)
print(f'\nКлетка1:\n{c1}\n{c1.make_order(5)}')
c2 = Cell(10)
print(f'\nКлетка2:\n{c2}\n{c2.make_order(5)}')


c3 = c1 + c2
print(f'\nКлетка1 + Клетка2:\n{c3}\n{c3.make_order(5)}')

c4 = c1 * c2
print(f'\nКлетка1 * Клетка2:\n{c4}\n{c4.make_order(12)}')

c5 = c1 - c2

print(f'\nКлетка1 - Клетка2:\n{c5}\n{c5.make_order(5)}')

c6 = c1 / c2
print(f'\nКлетка1 / Клетка2:\n{c6}\n{c6.make_order(5)}')

